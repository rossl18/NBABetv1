// API service for fetching data
// For GitHub Pages, you'll need to set up a serverless function or use direct DB queries
// This is a placeholder that can be adapted

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000'

export const getLatestBets = async () => {
  // Option 1: If using a serverless function (Vercel, Netlify, etc.)
  // const response = await fetch(`${API_BASE_URL}/api/bets`)
  // return response.json()
  
  // Option 2: For static site, use a JSON file that gets updated
  // This would be generated by GitHub Actions
  // Use correct path for local dev vs production
  const basePath = import.meta.env.PROD ? '/NBABetv1' : ''
  const url = `${basePath}/data/latest-bets.json`
  console.log('Fetching bets from:', url)
  console.log('Current location:', window.location.href)
  console.log('Environment:', import.meta.env.MODE)
  
  try {
    // Use AbortController for timeout - fail fast if file doesn't exist
    const controller = new AbortController()
    const timeoutId = setTimeout(() => {
      console.error('Aborting fetch after 1 second - taking too long')
      controller.abort()
    }, 1000) // 1 second timeout - very aggressive
    
    const fetchStart = Date.now()
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
      signal: controller.signal,
      cache: 'no-cache'
    })
    
    clearTimeout(timeoutId)
    const fetchTime = Date.now() - fetchStart
    console.log(`Fetch completed in ${fetchTime}ms, status: ${response.status}`)
    
    if (!response.ok) {
      console.warn(`Failed to fetch bets: ${response.status} ${response.statusText}`)
      console.warn('URL attempted:', url)
      console.warn('Response headers:', Object.fromEntries(response.headers.entries()))
      return []
    }
    
    const parseStart = Date.now()
    const data = await response.json()
    const parseTime = Date.now() - parseStart
    console.log(`JSON parsed in ${parseTime}ms`)
    console.log(`Successfully loaded ${Array.isArray(data) ? data.length : 0} bets`)
    
    // Validate that we got an array
    if (!Array.isArray(data)) {
      console.warn('Invalid data format: expected array, got:', typeof data)
      return []
    }
    
    // Normalize field names from capitalized to lowercase (e.g., Player -> player, Expected_Value -> expected_value)
    const normalizeStart = Date.now()
    const normalized = data.map(bet => ({
      player: bet.Player || bet.player,
      prop: bet.Prop || bet.prop,
      line: bet.Line || bet.line,
      over_under: bet['Over/Under'] || bet.over_under || bet.Over_Under,
      odds: bet.Odds || bet.odds,
      decimal_odds: bet.Decimal_Odds || bet.decimal_odds,
      implied_probability: bet.Implied_Probability || bet.implied_probability,
      model_probability: bet.Model_Probability || bet.model_probability,
      probability_ci_lower: bet.Probability_CI_Lower || bet.probability_ci_lower,
      probability_ci_upper: bet.Probability_CI_Upper || bet.probability_ci_upper,
      edge: bet.Edge || bet.edge,
      expected_value: bet.Expected_Value || bet.expected_value,
      ev_ci_lower: bet.EV_CI_Lower || bet.ev_ci_lower,
      ev_ci_upper: bet.EV_CI_Upper || bet.ev_ci_upper,
      kelly_fraction: bet.Kelly_Fraction || bet.kelly_fraction,
      kelly_adjusted_ev: bet.Kelly_Adjusted_EV || bet.kelly_adjusted_ev,
      confidence_score: bet.Confidence_Score || bet.confidence_score,
      historical_games: bet.Historical_Games || bet.historical_games,
      training_samples: bet.Training_Samples || bet.training_samples,
      generated_at: bet.Generated_At || bet.generated_at
    }))
    const normalizeTime = Date.now() - normalizeStart
    console.log(`Normalized ${normalized.length} bets in ${normalizeTime}ms`)
    return normalized
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Request timeout - file may not exist or server is slow')
    } else {
      console.error('Error fetching bets:', error)
      console.error('Error name:', error.name)
      console.error('Error message:', error.message)
      console.error('Error stack:', error.stack)
    }
    console.error('URL attempted:', url)
    // Return empty array on error - don't hang
    return []
  }
}

export const reloadBets = async () => {
  // This would trigger a serverless function or webhook
  // that runs the main_workflow.py script
  try {
    const response = await fetch(`${API_BASE_URL}/api/reload`, {
      method: 'POST'
    })
    return response.json()
  } catch (error) {
    console.error('Error reloading bets:', error)
    throw error
  }
}

export const getPerformanceData = async () => {
  try {
    // Use correct path for local dev vs production
    const basePath = import.meta.env.PROD ? '/NBABetv1' : ''
    const response = await fetch(`${basePath}/data/performance.json`)
    if (!response.ok) {
      // Return empty structure if file doesn't exist or fails to load
      return {
        totalBets: 0,
        wins: 0,
        losses: 0,
        winRate: 0,
        totalProfit: 0,
        roi: 0,
        byProp: [],
        overTime: []
      }
    }
    const data = await response.json()
    // Ensure we always return a valid structure
    return data || {
      totalBets: 0,
      wins: 0,
      losses: 0,
      winRate: 0,
      totalProfit: 0,
      roi: 0,
      byProp: [],
      overTime: []
    }
  } catch (error) {
    console.error('Error fetching performance:', error)
    // Return empty structure instead of null
    return {
      totalBets: 0,
      wins: 0,
      losses: 0,
      winRate: 0,
      totalProfit: 0,
      roi: 0,
      byProp: [],
      overTime: []
    }
  }
}
